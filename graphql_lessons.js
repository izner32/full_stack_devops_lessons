// LESSON 1.3 - SERVER SETUP WITH LATEST ECMASCRIPT

// step 1: npm init (package.json would now be installed) -> npm install --save-dev babel-cli babel-preset-env babel-preset-stage-0
// step 2: npm install express express-graphql graphql nodemon // nodemon is like live server, it automatically refresh
// step 3: create a new fiel: index.js and .babelrc (this could be hidden make sure it's not hidden)
// step 4: under script create "start":"nodemon ./index.js --exec babel-node -e js" // this would automatically run nodemon by saying npm run start 
// step 5: inside .babelrc: 
    {
        "presets": [
            "env",
            "stage-0"
        ]
    }
// step 6: inside index.js 
    const express = require("express");
    const app = express();

    app.get("/", (req,res) => {
        res.send("Graphql is amazing");
    }); 

    app.listen(8000, () => {
        console.log("Running on server port localhost:8000/graphql)
    });
// step 7: npm run start 

// LESSON 1.4 - INITIAL GRAPHQL SETUP - for now we would hardcode the response 
// step 1: create file - schema.js, inside type this 
    import { buildSchema } from "graphql";

    const schema = buildSchema(`
        type Query {
            hello: String 
        }
    `)

    export default schema 
// step 2: inside index.js 
    import schema from "./schema";
    import { graphqlHTTP } from "express-graphql"; // this is from the dependency we installed earlier 

    // under app.get 
    const root = { hello: ()=> "Hi, i'm renz" };

    app.use("/graphql", graphqlHTTP ({
        schema: schema, 
        rootValue: root, 
        graphiql: true, // a user interface that we can use to test whatever we want inside of our graphql server 

    }))
// step 3: now go to localhost:8000/graphql and see some magic (inside you can create queries)
    query {
        hello
    }
// step 4: run and see the result from query above 

// LESSON 1.5 - BASIC GRAPHQL SCHEMA 
// step 1: inside schema.js 
    import { buildSchema } from "graphql" // just destructuring 

    const schema = buildSchema(`
        type Friend {
            id: ID 
            firstName: String 
            lastName: String 
            gender: String 
            email: String
        }
        
        type Query {
            friend: Friend 
        }
    `)

// step 2: inside index.js 
    //change value of root - hardcoding data 




// LESSON C.3 - CORE CONCEPTS - schema, query, mutations, subscriptions 
// sdl (schema definition language)
// all type have unique id generated by the server 
type Person { // somehow looks like an interface
    name: String! // exclamation means this value is required
    age: Int! 
}

// adding a relation 
type Person { // first is create your own type 
    name: String! 
    age: Int!
} 

type Post { // look we're using type person in the author, just like in INTERFACE!!!!!!!
    title: String!
    author: Person!
}

// adding a multiple relation
type Person {
    name: String!
    age: Int!
    posts: [Post!]! // this means we're creating multiple values that has datatype Post | notice that we just defined a one to many relationship 
}

type Post {
    title: String! 
    author: Person! 
}

// fetching data with queries - rest api have multiple endpoints that return fixed data structures
// what you request is what you get, no more over and underfetching 
{ // we can also make a query by explicitly stating query {
    allPersons { // called as the root field
        name // this is also a field
        age
    }
}

// adding an argument, think of this as adding a condition or filter
{
    allPersons(last: 2) { // this woudl return last 2 items 
        name 
        age 
    }
}

// nesting queries
{
    allPersons { // grabbing all persons and their name and post, i mean do i really need to explain this, this is very intuitive already 
        name 
        post {
            title
        }
    }
}

// 3 kinds of mutation - creating, updating, and deleting 
// writing data with mutations
mutation { // if there is no keyword mutation it is automatically assumed as query
    createPerson(name: "Bob", age: 36) { // in this field we are creating, the arguments are the one we wanted to insert
        name // we write here everything we wanted to modify
        age 
    }
}

// subscription - real time update, client would have a real time connection to the server and the server would hold onto it 

// adding a mutation
// first create a field from the root type Mutation
type Mutation {
    createPerson (name: String!, age: String!): Person! // creating a way to mutate
}

mutation {
    createPerson(name:"Bob", age:36){ // we just used the field of mutation we created from above 
        id 
    }
}

// conclusions - full schema - including 3 route types: query, mutation, subscription 
type Query {
    allPersons(last: Int) : [Person!]! 
} 

type Mutation { // this completes the crud operation, look we have create,update and delete
    createPerson(name: String!, age: String!): Person! 
    updatePerson(id: ID!, name: String!, age: String!): Person!
    deletePerson(id: ID!): Person!
    createPost(title: String!): Post!
    updatePost(id: ID!, title: String!): Post!
    deletePost(id: ID!): Post!
}

type Subscription {
    newPerson: Person! 
    updatedPerson: Person! 
    deletedPerson: Person!
    newPost: Post!
    updatedPost: Post!
    deletedPost: Post!
} 

type Person {
    id: ID!
    name: String!
    age: Int! 
    posts: [Post!]! 
} 

type Post {
    title: String! 
    author: Person!
}







// LESSON X.1 - REST VS GRAPHQL 
/*
ENDPOINTS
restapi - embraces the concept of having multiple endpoints (e.g. GET/user, POST/product, PUT/user,etc.)
graphql - one endpoint only (e.g. POST/graphql)

JSON DATA IS EXCHANGED | SERVER SIDE LANGUAGE, ANY FRONTEND FRAMEWORK | BOTH ARE STATELESS 
restapi 
graphql 

COMMUNICATION WAY 
restapi - httpVerb/path { /* insert content here */ }  e.g. POST/user { name:"Max"} | multiple http verb, multiple path 
graphqlapi - httpVerb/path { query: "query" } e.g. POST/graphql { query: "query" } | one http verb, one path 

// LESSON X.2 - SCHEMA - i think this is just like an interface in typescript, it is a representation on how a structure must look like (this is just my guess)



