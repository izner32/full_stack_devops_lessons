// LESSON 1.1 - USER AUTHENTICATION 
// verifying that our applications users are who they say they are

// 3 main authentication strategy classes
    // the knowledge test - based on whethey or not they know something 
        // password
        // pin
        // security questions 
    // the ownership test - based on whether they have something, why am i even explaining this 
        // email address 
        // mobile phone 
        // otp fob or app
    // the biological test - based on hard to fake biological characteristics
        // facial recognition
        // fingerprint readers 
        // eye scans 
// two factor auth - combines knowledge and ownership

// LESSON 1.2 - BASIC PROJECT SETUP
// clone the react-starter-auth from the instructor in github https://github.com/shaunwa/react-auth-starter 

// lets start with front end -> look out for UserInfoPage, useQueryParams, and Routes
/*
step 1: cd front-end -> npm install -> npm run start -> ctrl + c to end 
step 2: cd back-end -> look out for server.js, db -> npm install -> npm run dev 
step 3: type mongod in terminal and let that mongodb running 
*/

// LESSON 1.3 - BUILDING A LOGIN PAGE 
/*
step 1: create a new file in page, LoginPage.js 
    // just the typical rfce 
    export const LogInPage = () => {
        return (
            <div className = "content-container">
                <h1>Log In</h1>
                <input 
                    placeholder = "someone@gmail.com" /> {/* default text that is in the input field */}
                <input 
                    type="password" {/* used to specify the type of input to display */}
                    placeholder="password" />
                <button>Log In</button>
                <button>Forgot your password?</button>
                <button>Don't have an account? Sign Up Now!</button>
            </div>
        )
    }
step 2: import useState to track the value of input fields, and useHistory for redirection, adding onClick events and error message
    import { useState } from "react"; // returns an array that contains the initial value and a function whcih could modify the value of the state 
    import { useHistory } from "react-router-dom"; // useHistory is used to go back to the previous page like clicking the back button in your webpage, but we could also use this so that instead of redirecting when they signed up they automatically go back after loading 

    const history = useHistory(); // sample use case: history.go(-1); // this means go back 1 page ago | history.push("/") push means redirect into this page 
    export const LogInPage = () => {
        const [errorMessage, setErrorMessage] = useState("");

        const [emailValue, setEmailValue] = useState("");
        const [passwordValue, setPasswordValue] = useState("");

        const history = useHistory();

        const onLogInClicked = async () => { // alert function is a async so we use async keyword here 
            alert("Log in not implemented yet"); // alert function is the method that typically shows you a warning 
        }

        return (
            <div className = "content-container">
                <h1>Log In</h1>
                {errorMessage && <div className="fail">{errorMessage}</div>}
                <input 
                    value={emailValue} {/* value is the value inside the input field */}
                    onChange={ e => setEmailValue(e.target.value)} {/* onChange executes everytime the value inside input field changes | trigger the setEmailValue that changes the emailValue, e.target.value is the current value inside the input field */}
                    placeholder = "someone@gmail.com" /> {/* default text that is in the input field */}
                <input 
                    type="password" {/* used to specify the type of input to display */}
                    value={passwordValue}
                    onChange={e => setPasswordValue(e.target.value)}
                    placeholder="password" />
                <hr />
                <button 
                    disabled={!emailValue || !passwordValue} {/* disabled is a boolean attribute, either a true or false | a string becomes false if the value is an empty string, this means this button is disabled when it has an empty string*/}
                    onClick={onLogInClicked}>Log In</button> 
                <button onClick={() => history.push("/forgot-password")}>Forgot your password?</button> {/* redirect into forgot-password page if this button is clicked */}
                <button onClick={() => history.push("/signup")}>Don't have an account? Sign Up Now!</button>
            </div>
        );
    }

// LESSON 1.4 - BUILDING A SIGN UP PAGE 
    import { useState } from "react"; // returns an array that contains the initial value and a function whcih could modify the value of the state 
    import { useHistory } from "react-router-dom"; // useHistory is used to go back to the previous page like clicking the back button in your webpage, but we could also use this so that instead of redirecting when they signed up they automatically go back after loading 

    const history = useHistory(); // sample use case: history.go(-1); // this means go back 1 page ago | history.push("/") push means redirect into this page 
    export const SignUpPage = () => {
        const [errorMessage, setErrorMessage] = useState("");

        const [emailValue, setEmailValue] = useState("");
        const [passwordValue, setPasswordValue] = useState("");
        const [confirmPasswordValue, setConfirmPasswordValue] = useState(""); // adding a confirmation

        const history = useHistory();

        const onSignUpClicked = async () => { 
            alert("Sign Up not implemented yet"); 
        }

        return (
            <div className = "content-container">
                <h1>Sign Up</h1>
                {errorMessage && <div className="fail">{errorMessage}</div>}
                <input 
                    value={emailValue} 
                    onChange={ e => setEmailValue(e.target.value)} 
                    placeholder = "someone@gmail.com" /> 
                <input 
                    type="password" 
                    value={passwordValue}
                    onChange={e => setPasswordValue(e.target.value)}
                    placeholder="password" />
                <input {/* confirm password input */}
                    type="password" 
                    value={confirmPasswordValue}
                    onChange={e => setConfirmPasswordValue(e.target.value)}
                    placeholder="password" />
                <hr />
                <button 
                    disabled={ !emailValue || !passwordValue ||
                    passwordValue !== confirmPasswordValue } {/* disable button if these values isn't true */}
                    onClick={onSignUpClicked}>Sign Up</button> 
                <button onClick={() => history.push("/login")}>Already have an account? Log In Now!</button>
            </div>
        );
    }

// LESSON 1.5 - CREATING PRIVATE ROUTES - we want only authenticated users to see private pages 
// step 1: create a new directory in src named auth and inside create a PrivateRoute.js - it's like a react routers except if a user isn't logged in, it's going to automatically redirect them to the login page 
import { Redirect, Route } from "react-router-dom";

export const PrivateRoute = (props) => {
    // just giving an initial value since we havent implemented login yet 
    const user = null; 

    // if the user isn't logged in redirect them into this page 
    if (!user) return <Redirect to="/login" /> // syntax for redirect component of react-router-dom, nothing really special 

    // if the user is logged in return route that would allow them to accces private routes 
    return <Route {...props} />
}

// step 2: import the components you have just made in the routes file 
import { BrowserRouter as Router, Route, Switch } from "react-router-dom";
import { LogInPage } from "./pages/LogInPage";
import { SignUpPage } from "./pages/SignUpPage";
import { UserInfoPage} from "./pages/UserInfoPage";

export const Routes = () => {
    return (
        <Router>
            <Switch>
                <PrivateRoute path="/" exact> {/* remember that private route return Route */}
                    <UserInfoPage />
                </PrivateRoute>
                <PrivateRoute path="/login" exact>
                    <LogInPage />
                </PrivateRoute>
                <Route path="/signup" exact>
                    <SignUpPage />
                </Route>
            </Switch>
        </Router>
    )
}

// LESSON 1.6 - JSON WEB TOKEN (JWT) BASICS - strings that we give to users when they authenticate | can be used instead of the user's password to interact with protected server resources
// 3 main auth strat - knowledge,ownership,biological based 
// an example of what jwt might look like: eyJhBASD.FsadfJazSGxoASpa.SdfmOSidn // consists of header, payload, and signature | this form is encoded form of jwt 
    // this form below is an example of decoded 
    // header - this contains like this 
        { 
            "alg":"HS256",
            "typ":"JWT"
        }
    // payload - actual data that the jwt contains 
        {
            "id":"123",
            "email":"afs@gmail.com",
            "likesCoffee":true,
        }
    // signature - used to verify the authenticity of the other parts 

// how jwts are used in full stack apps - jwts are credentials, be careful with them 
    // step 1: the user logs in 
    // step 2: the server generates a jwt containing the user's information 
    // step 3: the server sends the jwt to the user's browser  
    // step 4: the front end stores this jwt 
    // step 5: the front end includes this jwt whenever it needs privileged access
    // step 6: the server uses the jwt's signature to verify that it hasn't been modified 

// signing - proves that the data in the jwt hasn't been modifeid 
// encrypting - prevents third parties from seeing the data inside the jwt 

// benefits of jwts 
    // jwts are stateless - all of the infor that jwt contain is inside the token itself, it doesnt require our backend to actively tracked who's logged in, no more login=true, login=false 
    // uses json, which is more compact and secure than using xml 

// drawbacks of jwt 
    // tokens are valid until they expire or until the private key is changed 
    
// LESSON 1.7 - ADDING A SIGN UP ROUTE TO THE SERVER - backend file, we're creating an api but in a somehow different format because it's not inside the server.js file | we would create a post api that adds to the database 
// step 1: create a signUpRoute.js file into the src>routes 
    export const signUpRoute = {
        path:"/api/signup",
        method:"post",
        handler:async (req,res) => {

        }
    }

// step 2: install bcrpyt to encrypt the user's password - npm install bcrypt dotenv jsonwebtoken // bcrypt for encrypting password, dotenv used for loading env variables from a file, jsonwebtoken used for signing and verifying things 
// step 3: connect to database, encrypt password because if we simply store it in database and a hacker had access into this he would have easily collect all of the user's passwords
    import bcrpyt from "bcrypt";
    import jwt from "jsonwebtoken";
    import { getDbConnection } from "../db";

    export const signUpRoute = {
        path:"/api/signup",
        method:"post",
        handler:async (req,res) => {
            const { email, password } = req.body; // getting the email and password from the input field 

            // connecting to the database
            const db = getDbConnection("react-auth-db");
            const user = await db.collection("users").findOne({ email }); // find one value of email from the collection users in the database 
        
            // if the user exists, send an error message
            if (user) {
                res.sendStatus(409);
            }

            // encrypt password 
            const passwordHash = await bcrypt.hash(password,10); // second argument is the number of iteration we want it to use when it encrypts their password, 10 is just a good rule of thumb of default  
        
            // create a new user in our database with all of these data 
            const startingInfo = {
                hairColor: "",
                favoriteFood: "",
                bio: "",
            };

            // creating new user with the info above and inserting them into the database 
            const result = await db.collection("users").insertOne({
                email,
                passwordHash, // ofc we would send passwordHash 
                info: startingInfo,
                isVerified: false,
            });

            // when mongodb inserts a document it automatically assigns an id (look at mongodb_lessons)
            const { insertedID } = result; // grabbing the id generated by mongodb 
        }
    }

// LESSON 1.8 - GENERATING JSON WEB TOKENS 
// step 1: generate json web tokens 
    import bcrpyt from "bcrypt";
    import jwt from "jsonwebtoken";
    import { getDbConnection } from "../db";

    export const signUpRoute = {
        path:"/api/signup",
        method:"post",
        handler:async (req,res) => {
            const { email, password } = req.body; // getting the email and password from the input field 

            // connecting to the database
            const db = getDbConnection("react-auth-db");
            const user = await db.collection("users").findOne({ email }); // find one value of email from the collection users in the database 
        
            // if the user exists, send an error message
            if (user) {
                res.sendStatus(409);
            }

            // encrypt password 
            const passwordHash = await bcrypt.hash(password,10); // second argument is the number of iteration we want it to use when it encrypts their password, 10 is just a good rule of thumb of default  
        
            // create a new user in our database with all of these data 
            const startingInfo = {
                hairColor: "",
                favoriteFood: "",
                bio: "",
            };

            // creating new user with the info above and inserting them into the database 
            const result = await db.collection("users").insertOne({
                email,
                passwordHash, // ofc we would send passwordHash 
                info: startingInfo,
                isVerified: false,
            });

            // when mongodb inserts a document it automatically assigns an id (look at mongodb_lessons)
            const { insertedId } = result; // grabbing the id generated by mongodb 

            // generate a json web token with all of these info except obviously passwordHash 
            jwt.sign({
                id: insertedId,
                email,
                info: startingInfo,
                isVerified: false,
            })
        }
    }
// step 2: create a new file in the backend called .env, this is where we store environment variables
// inside .env 
    JWT_SECRET=asdfasdfadd // but in real case scenario, it's a good idea to use password generator 
    // in real life you might want to do this 
        // go to terminal -> node 
        // require("crypto").randomBytes(64).toString("hex"); // this gives us different strings everytime we refresh | watch this on youtube https://www.youtube.com/watch?v=mbsmsi7l3r4 8:25 timeframe
// step 3: go back to jwt.sign inside signUpRoutes
            jwt.sign({ // 1st argument is all of the data we wanted to include in the web token | 2nd argument is the jwt secret | 3rd arugment is optional, how long does we want the jwt to expire | 4th argument is a callback that occurs whe nevereything is okay  
                id: insertedId,
                email,
                info: startingInfo,
                isVerified: false,
            },
            process.env.JWT_SECRET, // this returns an object containing the value of environment variable jwt_secret 
            {
                expiresIn: "2d",
            },
            (err, token) => {
                if (err) {
                    return res.status(500).send(err);
                } else {
                    // status 200 is ok 
                    res.status(200).json({ token });
                }
            });
// step 4: add what we did inside index.js 
// step 5: add in package.json, at script -> inside dev script -> babel-node -r dotenv/config // this would make all of the .env package load right when the server starts in
// step 6: test what we just did in postman, create a post to the api endpoint of signup, inside body type the email and password andd see if it works, we should be getting back a json web token 

// LESSON 1.9 - ADD A LOGIN ROUTE TO THE SERVER 
// step 1: create a loginRoute.js from src>routes, inside loginRoute 
    import bcrypt from "bcrypt"
    import jwt from "jsonwebtoken";
    import { getDbConnection } from "../db";

    export const loginRoute = {
        path:"/api/login",
        method:"post",
        handler:async (req,res) => {
            const { email, password } = req.body; // getting the email and password from the input field 

            // connecting to the database
            const db = getDbConnection("react-auth-db");
            const user = await db.collection("users").findOne({ email }); // find one value of email from the collection users in the database 
        
            // check first if the user exists 
            if (!user) return res.sendStatus(401); // send an error if the user doesn't exist 

            // getting the necessary info from the user so we have something to compare on 
            const { _id: id, isVerified, passwordHash, info } = user;

            // compare the password that is being submitted to this route, to the password hash, we would do this by also hashing the password passed 
            const isCorrect = await bcrypt.compare(password, passwordHash); // compare returns boolean if the two matches or not while hashing the first argument 

            if (isCorrect){
                jwt.sign(
                    { id, isVerified, email, info }, 
                    process.env.JWT_SECRET,
                    { expiresIn: "2d" },
                    (err, token) => {
                        if (err) {
                            res.status(500).json(err);
                        }
                        res.status(200).json({ token })
                    })
            } else {
                res.sendStatus(401); // if isCorrect is false then do this 
            }
        }
    }
// step 2: export this route 
// step 3: import it in index.js, thins index.js then gets executed inside the server.js where it calls all of the routes 
import { loginRoute } from "./loginRoute";
import { signUpRoute } from "./signUpRoute";
import { testRoute } from "./testRoute";

export const routes = [
    loginRoute,
    signUpRoute,
    testRoute,
];

// step 4: test in api the route we just created 

// LESSON 1.10 - IMPLEMENTING JWTS ON THE FRONT END - storing jwt inside the browser so as long as there is jwt the user is still logged in 
// step 1: create a file at src>auth, namely useToken.js and useUser.js 
    // inside useToken.js 
    import { useState } from "react";

    export const useToken = () => { // defining our own hook that utilizes useState
        const [token,setTokenInternal] = useState( () => {
            // getting the value of token inside the lcoal storage and set that as the initial value of token 
            return localStorage.getItem("token"); // getting the value of token from local storage 
        });

        const setToken = newToken => { // this function sets the passed token as the new token value 
            localStorage.setItem("token",newToken); // set the value of token in the local storage to whatever the newToken value that was passed in 
            setTokenInternal(newToken);
        }

        return [token,setToken];
    }

// step 2: inside useUser.js use the useToken hook we just created
    import { useState, useEffect } from "react";
    import { useToken } from "./useToken"; // importing our created hook that uses useState 

    export const useUser = () => {
        const [token] = useToken(); // getting the jwt from our created hook 

        // grabbing the payload or data from the token 
        const getPayloadFromToken = token => {
            const encodedPayload = token.split(".")[1]; // since token is a string we can use builtin methods with it, string.split() would return an array of strings, in this case we would want to access the first index string which is the payload or the main data that the token holds
            return JSON.parse(atob(encodedPayload)); // remember that atob decodes a base64 string and converts them into string, this string is the object that the token contains and we're converting it into a javascript object 
        }

        const [user, setUser] = useState(() => { // user contains the payload from token 
            if (!token) return null; // if there is no token return null 
            return getPayloadFromToken(token); // remember that getpayloadfromtoken returns the object data or payload of the token we're passing 
        });

        useEffect(() => {
            if (!token) { // if no token then set the user to null 
                setUser(null);
            } else {
                setUser(getPayloadFromToken(token)); // of there is token get the info about user thru payload 
            }
        }, [token]); // do this everytime the token changes, and the token only changes when the user logged in,logged out or changed 

        return user;
    }

// LESSON 1.11 - ADDING JWTS TO SIGN UP PAGE 
// step 1: import axios, yeah we gonna fetch those apis with axios -> add useToken -> modifying content of onSignUpClicked by fetching the signUpRoute api when the button has been clicked 
    import { useState } from "react"; 
    import axios from "axios"; // importing axios for fetching api 
    import { useHistory } from "react-router-dom"; 

    const history = useHistory(); // used for redirection 
    export const SignUpPage = () => {
        const [token, setToken] = useToken();
        const [errorMessage, setErrorMessage] = useState("");

        const [emailValue, setEmailValue] = useState("");
        const [passwordValue, setPasswordValue] = useState("");
        const [confirmPasswordValue, setConfirmPasswordValue] = useState(""); 

        const history = useHistory();

        // updating on signup clicked 
        const onSignUpClicked = async () => { 
            // 1st param on axios.post is the api endpoint we want, and second is the content of our post request 
            const response = await axios.post("/api/signup", {
                email: emailValue,
                password: passwordValue,
            }});
            const { token } = response.data; // grabbing the jwt token that the response sets for us 
            setToken(token); / setting the token given to us and you that setToken puts it into the local storage 
            history.push("/"); // sending them to the home route after signing up 
        }

        return (
            <div className = "content-container">
                <h1>Sign Up</h1>
                {errorMessage && <div className="fail">{errorMessage}</div>}
                <input 
                    value={emailValue} 
                    onChange={ e => setEmailValue(e.target.value)} 
                    placeholder = "someone@gmail.com" /> 
                <input 
                    type="password" 
                    value={passwordValue}
                    onChange={e => setPasswordValue(e.target.value)}
                    placeholder="password" />
                <input 
                    type="password" 
                    value={confirmPasswordValue}
                    onChange={e => setConfirmPasswordValue(e.target.value)}
                    placeholder="password" />
                <hr />
                <button 
                    disabled={ !emailValue || !passwordValue ||
                    passwordValue !== confirmPasswordValue } 
                    onClick={onSignUpClicked}>Sign Up</button> 
                <button onClick={() => history.push("/login")}>Already have an account? Log In Now!</button>
            </div>
        );
    }
// step 2: go to PrivateRoute.js 
import { Redirect, Route } from "react-router-dom"; // redirect is a functional component that somehow works like a history hook 
import { useUser } from "./useUser";

export const PrivateRoute = (props) => {
    const user = useUser(); // useUser identifies if the user is valid  

    if (!user) return <Redirect to="/login" />

    return <Route {...props} /> // we are now redirected into the homepage or the user info page 
}
// step 3: inspect elements -> application -> local storage -> localhost:3000 -> in here you could see the value of the token 

// LESSON 1.12 - ADDING JWTS TO LOGIN PAGE 
// step 1: add axios and useToken 
    import { useState } from "react"; 
    import { useHistory } from "react-router-dom"; 
    import axios from "axios"; // importing axios 
    import { useToken } from "./useToken" // importing our created hooks 

    const history = useHistory(); // sample use case: history.go(-1); 
    export const LogInPage = () => {
        const [token, setToken] = useState(); // added 
        const [errorMessage, setErrorMessage] = useState("");

        const [emailValue, setEmailValue] = useState("");
        const [passwordValue, setPasswordValue] = useState("");

        const history = useHistory();

        // update onLogInClicked
        const onLogInClicked = async () => { 
            // fetch a post api request wid axios 
            const response = await axios.post("/api/login", {
                email: emailValue,
                password: passwordValue,
            });
            const { token } = response.data; // grabbing the token from the repsonse of the api 
            setToken(token); // updating token 
            history.push("/");
        }

        return (
            <div className = "content-container">
                <h1>Log In</h1>
                {errorMessage && <div className="fail">{errorMessage}</div>}
                <input 
                    value={emailValue} 
                    onChange={ e => setEmailValue(e.target.value)} 
                    placeholder = "someone@gmail.com" /> 
                <input 
                    type="password" 
                    value={passwordValue}
                    onChange={e => setPasswordValue(e.target.value)}
                    placeholder="password" />
                <hr />
                <button 
                    disabled={!emailValue || !passwordValue}
                    onClick={onLogInClicked}>Log In</button> 
                <button onClick={() => history.push("/forgot-password")}>Forgot your password?</button> 
                <button onClick={() => history.push("/signup")}>Don't have an account? Sign Up Now!</button>
            </div>
        );
    }

// LESSON 1.13 - ADDING AN UPDATE USER ROUTE 
step 1: udner src>routes> create a file named updateUserInfoRoute.js 
    import jwt from "jsonwebtoken"; 
    import { ObjectID } from "mongodb";
    import { getDbConnection } from "../db"; // this connects to the database

    export const updateUserInfoRoute = {
        path: "/api/users/:userId", // applying url parameter to specify the user id 
        method: "put", // put is used for updating but it can also create when the data doesn't exist 
        handler: async (req,res) => {
            const { authorization } = req.headers; // get the authorization header from the client, client must send the json web token when fetching this api request 
            const { userId } = req.params; // getting the value of userId from the req.params 
        
            // get the updates from the req.body (.body is the content in which was sent from fetching)
            const updates = ({ // define an anonymous function 
                favoriteFood, // we're only grabbing three properties from the content that was send by fetching this api 
                hairColor,
                bio,
            }) => ({ // that returns an object 
                favoriteFood,
                hairColor,
                bio,
            }))(req.body);

            // check if the user has sent an authorization 
            if (!authorization) {
                return res.status(401).json({ message: "No authorization header sent" });
            }

            // authorization's header gonna look like this Bearer dfgsdfgsdf123.4asdf so we remove the Bearer and only grab our auth token 
            const token = authorization.split(" ").[1]; 
        }
    } 

// LESSON 1.14 - VERIFYING JSON WEB TOKENS - verifying that it hasn't been tampered 
step 1: we're still inside the updateUserInfoRoute.js 
    // verifying if it has been tampered or modified
    jwt.verify(token, process.env.JWT_SECRET, async (err, decoded) => {
        if (err) return res.status(401).json({ message: "Unable to verify token" }); // this means it has been tampered 
    
        // if no error grab the id from the decoded form of jwt 
        const { id } = decoded; // decoded is the readable or json form of jwt 

        // make sure that the id they're trying to update matches their id 
        if (id !== userId) return res.status(403).json({ message: "Not allowed to update that user's data" }); // sending back a json since api can only send back a json remember 
    
        // connecting to database 
        const db = getDbConnection("react-auth-db");
        const result = await db.collection("users").findOneAndUpdate( // wow so there is a mongodb query where you can find and update simultaneously
            { _id: ObjectID(id) }, // find in mongodb the one that matches the user's id 
            { $set: { info: updates } },
            { returnOriginal: false }, // this is important so that the query would return the updated not the original
        );

        // get the relevant data, we already have their and send back to the client 
        const { email, info } = result.value; // result.value is the data from the mongodb object 

        // create a jwt token  
        jwt.sign({ id, email, isVerified, info }, process.env.JWT_SECRET, { expiresIn: "2d" }, (err, token) => {
            if (err) {
                return res.status(200).json(err);
            }
            res.status(200).json({ token }); // send back the token if succesful 
            }
        })
    })

// LESSON 1.15 - ADDING JWTS TO THE USER INFO PAGE - user info page can only be accessed when you are logged in with the proper jwt 
step 1: import useToken (the hook we created), useUser and axios(for fetching)
    import { useState, useEffect } from 'react';
    import { useHistory } from 'react-router-dom';
    import { useToken } from "../auth/useUser";

    export const UserInfoPage = () => {
        // We'll use the history to navigate the user
        // programmatically later on (we're not using it yet)
        const history = useHistory();

        // These states are bound to the values of the text inputs
        // on the page (see JSX below). 
        const [favoriteFood, setFavoriteFood] = useState('');
        const [hairColor, setHairColor] = useState('');
        const [bio, setBio] = useState('');

        // These state variables control whether or not we show
        // the success and error message sections after making
        // a network request (see JSX below).
        const [showSuccessMessage, setShowSuccessMessage] = useState(false);
        const [showErrorMessage, setShowErrorMessage] = useState(false);

        // This useEffect hook automatically hides the
        // success and error messages after 3 seconds when they're shown.
        // Just a little user interface improvement.
        useEffect(() => {
            if (showSuccessMessage || showErrorMessage) {
                setTimeout(() => {
                    setShowSuccessMessage(false);
                    setShowErrorMessage(false);
                }, 3000);
            }
        }, [showSuccessMessage, showErrorMessage]);

        const saveChanges = async () => {
            // Send a request to the server to
            // update the user's info with any changes we've
            // made to the text input values
            alert('Save functionality not implemented yet');
        }

        const logOut = () => {
            // We'll want to log the user out here
            // and send them to the "login page"
            alert('Log out functionality not implemented yet');
        }
        
        const resetValues = () => {
            // Reset the text input values to
            // their starting values (the data we loaded from the server)
            alert('Reset functionality not implemented yet');
        }
        
        // And here we have the JSX for our component. It's pretty straightforward
        return (
            <div className="content-container">
                <h1>Info for ______</h1>
                {showSuccessMessage && <div className="success">Successfully saved user data!</div>}
                {showErrorMessage && <div className="fail">Uh oh... something went wrong and we couldn't save changes</div>}
                <label>
                    Favorite Food:
                    <input
                        onChange={e => setFavoriteFood(e.target.value)}
                        value={favoriteFood} />
                </label>
                <label>
                    Hair Color:
                    <input
                        onChange={e => setHairColor(e.target.value)}
                        value={hairColor} />
                </label>
                <label>
                    Bio:
                    <input
                        onChange={e => setBio(e.target.value)}
                        value={bio} />
                </label>
                <hr />
                <button onClick={saveChanges}>Save Changes</button>
                <button onClick={resetValues}>Reset Values</button>
                <button onClick={logOut}>Log Out</button>
            </div>
        );
    }

// step 2: add this just below the export const UserInfopage = () => {
        const user = useUser();
        const [token,setToken] = useToken(); 
        // grab info from user 
        const { id, email, info } = user;

// step 3: use the info we got from user to populate the initial values for our text boxes down here 
    // These states are bound to the values of the text inputs
    // on the page (see JSX below). 
    const [favoriteFood, setFavoriteFood] = useState(info.favoriteFood || ""); // make the value empty string if there is no favoriteFood 
    const [hairColor, setHairColor] = useState(info.hairColor || "");
    const [bio, setBio] = useState(info.bio || "");

// step 4: make a network request to the endpoint we just created
    const saveChanges = async () => {
        try {
            const response = await axios.put(`/api/users/${id}`, {
                favoriteFood,
                hairColor,
                bio,
            }, {
                headers: { Authorization: `Bearer ${token}`} // sending our jwt token to allow us to modify our info 
            });

            const { token:newToken } = response.data;
            setToken(newToken);
            setShowSuccessMessage(true);
        }   catch (error) {
            setShowErrorMessage(true);
        }
    }

// step 5: implement reset values and display the user's email 
    const resetValues = () => { // when the user click the reset button, we would set the property into its initial values 
        setFavoriteFood(info.favoriteFood);
        setHairColor(info.hairColor);
        setBio(info.bio)
    }

    // display user's email 
    return (
        <div className="content-container">
            <h1>Info for {email}</h1>
            {showSuccessMessage && <div className="success">Successfully saved user data!</div>}
            {showErrorMessage && <div className="fail">Uh oh... something went wrong and we couldn't save changes</div>}
            <label>
                Favorite Food:
                <input
                    onChange={e => setFavoriteFood(e.target.value)}
                    value={favoriteFood} />
            </label>
            <label>
                Hair Color:
                <input
                    onChange={e => setHairColor(e.target.value)}
                    value={hairColor} />
            </label>
            <label>
                Bio:
                <input
                    onChange={e => setBio(e.target.value)}
                    value={bio} />
            </label>
            <hr />
            <button onClick={saveChanges}>Save Changes</button>
            <button onClick={resetValues}>Reset Values</button>
            <button onClick={logOut}>Log Out</button>
        </div>
// step 6: make sure that the routes are all in there inside index.js 
    // index.js 
    import { logInRoute } from "./logInRoute";
    import { signUpRoute } from "./signUpRoute";
    import { testRoute } from "./testRoute";
    import { updateUserInfoRoute } from "./updateUserInfoRoute"
        
    export const routes = [
        logInRoute,
        signUpRoute,
        testRoute,
        updateUserInfoRoute,
    ];

// LESSON 1.16 - ADDING LOGOUT FUNCTIONALITY - logout is simply by deleting jwt token that was stored in the local storage 
// inside UserInfoPage.js 
    const logOut = () => {
        localStorage.removeItem("token");
        history.push("/login"); // go to login page 
    }

// LESSON 2.1 BASIC EMAIL VERIFICATION PROCESS - we need to make sure that our users own the email addresses they're signing up with 
// email verification flow 
    1. the user creates a new account with their email and password
    2. the server add this information to the database 
    3. the server also generates a secret verification hash that the user cant see - this will be used to prove that the user actually has access to that email address 
    4. the server sends an email link with this verification hash to provided email address
    5. if the user really owns the email, they can click this link which sends them to a special landing page in our application 
    6. the landing page parses the verification hash from the url and sends it to the server 
    7. if the verification hash matches, the user is marked as "verified"

// LESSON 2.2 - SETTING UP AN EMAIL PROVIDER 
// step 1: set up an email provider or service that takes care of sending emails on our behalf, in our case we would use sendGrid which is more friendly than other services like mailgun or amazon ses
    - click create a single sender button 
    - fill the form 
    - verify email address in sendgrid(y am i even including this step)
// step 2: create an api key that will allow our backend to send emails thru this address 
    - email api -> integration guide -> node js 
    - just follow their guide 
// step 3: go to your .env file and create SENDGRID_API_KEY = {paste the key here}
    - make sure you don't have a local environment variable with the same name as SENDGRID_API_KEY before, to check, type: echo $SENDGRID_API_KEY ,if you saw nothing then it's all good, if you saw a long string then that means you've already done something with sendGrid in the past and that might cause trouble 
// step 4: npm install --save @sendgrid/mail 

// LESSON 2.3 - SENDING EMAILS FROM NODE 
// step 1: inside src>routes> create new file named testEmailRoute.js 
// step 2: inside src> create a new file named util > create a new file sendEmail.js 
    // inside sendEmail.js 
    import sendgrid from "@sendgrid/mail";

    sendgrid.setApiKey(process.env.SENDGRID_API_KEY); // set the api key that we added from the .env file for sendgrid 

    export const sendEmail = ({ to, from, subject, text, html }) => {
        const msg = { to, from, subject, text, html};
        return sendgrid.send(msg); // this sendgrid.send returns a promise 
    }
// step 3: go to testEmailRoute.js 
    import { sendEmail } from "../util/sendEmail";

    export const testEmailRoute = {
        path: "/api/test-email",
        method: "post",
        handler: async (req,res) => {
            try {
                await sendEmail({ // content of the test email we'll be sending 
                    to: "shuan.linkedin.learning+test@gmail.com",
                    from: "shaun.linkedin.learning@gmail.com", // email you created in sendgrid 
                    subject: "Does this work?",
                    text: "if you're reading this then this works"
                });
                res.sendStatus(200);
            } catch (e) {
                console.log(e);
                res.sendStatus(500);
            }
        }
    }
// step 4: import that into the index.js (where all routes are placed)
// step 5: test it out on postman

// LESSON 2.4 - INTEGRATING VERIFICATION TOKENS 
// step 1: npm install uuid 
// step 2: go to signUpRoute.js, import { v4 as uuid } from "../db";
// step 2.5: create variable for verification string -> post it into the database including with emails, passwordHash, etc. -> create a try block catch for error handling when sending emails 
    import bcrpyt from "bcrypt";
    import jwt from "jsonwebtoken";
    import { getDbConnection } from "../db";
    import { v4 as uuid } from "../db"; // importing uuid 
    import { sendEmail } from "../util/sendEmail";

    export const signUpRoute = {
        path:"/api/signup",
        method:"post",
        handler:async (req,res) => {
            const { email, password } = req.body; 

            // connecting to the database
            const db = getDbConnection("react-auth-db");
            const user = await db.collection("users").findOne({ email }); 
        
            // if the user exists, send an error message
            if (user) {
                res.sendStatus(409);
            }

            // encrypt password 
            const passwordHash = await bcrypt.hash(password,10); 
        
            // added this 
            const verificationString = uuid(); // this would generate a unique verification id for us 

            // create a new user in our database with all of these data 
            const startingInfo = {
                hairColor: "",
                favoriteFood: "",
                bio: "",
            };

            // creating new user with the info above and inserting them into the database 
            const result = await db.collection("users").insertOne({
                email,
                passwordHash, 
                info: startingInfo,
                isVerified: false,
                verificationString, // added this 
            });

            // when mongodb inserts a document it automatically assigns an id (look at mongodb_lessons)
            const { insertedId } = result; 

            // added this try catch block to handle error if something goes wrong when sending email 
            try {
                await sendEmail({
                    to: email,
                    from: "shaun.linkedin.learning@gmail.com",
                    subject: "Please verify your email",
                    text:" Thanks for signing up! To verify your email, click here:
                    http://localhost:300/verify-email/${verificationString}"
                })
            } catch (e) {
                console.log(e);
                res.sendStatus(500);
            }

            // generate a json web token with all of these info except obviously passwordHash 
            jwt.sign({ 
                id: insertedId,
                email,
                info: startingInfo,
                isVerified: false,
            },
            process.env.JWT_SECRET, 
            {
                expiresIn: "2d",
            },
            (err, token) => {
                if (err) {
                    return res.status(500).send(err);
                } else {
                    // status 200 is ok 
                    res.status(200).json({ token });
                }
            });
        }
    }

// step 3: go to updateUserInfoRoute.js 
    // i won't copy the whole code anymore
    // just below this code 

    // if no error do this 
    // add isVerified 
        const { id, isVerified } = decoded; // decoded is the user's data that they sent 
        if (!isVerified) return res.status(403).json({message: "You need to verify your email before you can update your data"})
// step 4: test it by signing up
// step 5: verify our email, after clicking the link it would take us to the correct link but since we havent set up a frontend, there's nothing to see yet 
// FIX BUG - STATUS 409 WHICH MEANS WE CREATED AN ACCOUNT IN OUR DATABASE BEFORE WE SENT AN EMAIL, BUT IT STILL CREATED AN ACCOUNT NEVERTHELESS 

// LESSON 2.5 - CREATING A VERIFY EMAIL PAGE 
// step 1: pages > PleaseVerifyEmailPage.js 
    import { useEffect } from "react";
    import { useHistory } from "react-router-dom";

    export const PleaseVerifyEmailPage = () => {
        const history = useHistory();

        // use useEffect hook to make this page navigate away after a few seconds 
        useEffect(() => {
            setTimeout(() => {
                history.push("/");
            }, 3000);
        }, [history]); // remember that useEffect executes everytime the 2nd arguemnt or dependency changes 

        return (
            <div className="">
                <h1>Thanks for Signing Up!</h1>
                <p>
                    A verification email has been sent to the email address, Please verify your email to unlock full site features 
                </p>
            </div>
        );
    }
// step 2: add this verify email page to the spa routes 
// step 3: on signUpPage go to onSignUpClicked function and modify the history.push('/') into history.push("/please-verify"); // which goes to the email verification page 
// step 4: inside userInfoPage.js, add this specific piece of code 
    export const UserInfoPage = () => {
        const user = useUser();
        const [token, setToken] = useToken();

        const { id, email, isVerified, info } = user; // add the isVerified 
    }

// step 4.5: go to userInfoPage and don't allow user to update their info without verifying email 
    return (
        <div className="content-container">
            <h1>Info for {email}</h1>
            {!isVerified && <div className="fail">You won't be able to make any changes until you verify your email</div>}
    )

// LESSON 2.6 - ADDING A VERIFY EMAIL ROUTE - implementing actual verification itself, 
// user clicks the link from verification email with the code we generated -> send them to landing page as well as a route that we can send that code that we generated to mark their email as verified -> this requires changes to frontend and backend 
// let's start changing with backend 
// step 1: create a file named verifyEmailRoute.js, inside do this 
    import { ObjectID } from "mongodb"; // used to find the users in our database by their id 
    import jwt from "jsonwebtoken";
    import { getDbConnection } from "../db";

    export const verifyEmailRoute = {
        path: "/api/verify-email", // path is the api endpoint 
        method: "put", // http method 
        handler: async (req,res) => {
            const { verificationString } = req.body; // grab the verificationString from the req.body that the client sent 
            const db = getDbConnection("react-auth-db"); // connecting to a database named getDbConnection 
            const result = await db.collection("users").findOne({ // find the user with this verification string in the database, find the one that matches 
                verificationString, // variable result contains an object containing the data of the user 
            })

            // if there are no result that means no match then send this message 
            if (!result) return res.status(401).json({ message: "The email verification code is incorrect"}) // study more about res.status 
        
            // if there is a result meaning there is a match, then mark that user as verified 
            const { _id: id, email, info } = result; // research the purpose of _id 

            // mark the user as verified 
            await db.collection("users").updateOne({ _id: ObjectID(id)}, { // 1st parameter is search the one that matches the id 
                $set: { isVerified: true }
            });

            // send the information back to the user
            jwt.sign({ id, email, isVerified: true, info }, process.env.JWT_SECRET, { expiresIn: "2d"}, (err,token) => {
                if (err) return res.sendStatus(500); 
                res.status(200).json({ token })// send the token back to the user 
            }) 
        }
    }
// step 2: export this route to the index file(main route of all api)
import { loginRoute } from "./loginRoute";
import { signUpRoute } from "./signUpRoute";
import { testRoute } from "./testRoute";
import { updateUserInfoRoute } from "./updateUserInfoRoute";
import { verifyEmailRoute } from "./verifyEmailRoute";

export const routes = [
    loginRoute,
    signUpRoute,
    testRoute,
    updateUserInfoRoute,
    verifyEmailRoute,
];

// LESSON 2.7 - CREATING A VERIFICATION LANDING PAGE 
// step 1: src>pages> create a new file EmailVerificationLandingpage.js, EmailVerificationSuccess.js, EmailVerificationFail.js
    // inside EmailVerificationLandingPage 
    import { useState, useEffect } from "react";
    import { useParams } from "react-router-dom" // use this to get the verification code out of the url when the user clicks on the link 
    unoirt axios from "axios"; // for fetching 
    import { useToken } from "../auth/useToken";

    // importing the two landing pages 
    import { EmailVerificationSuccess } from "./EmailVerificationSuccess";
    import { EmailVerificationFail } from "./EmailVerificationFail";

    export const EmailVerificationLandingPage = () => {
        const [isLoading, setIsLoading] = useState(true); // know if its loading or not 
        const [isSuccess, setIsSuccess] = useState(false); // state that tells us whether its a success or not 
        const { verificationString } = useParams(); // get the string from the url parameter, remember that we integrated the verification code in the url string 
        const [,setToken] = useToken(); // only grabbing the seToken 
    
        // make the request to the server endpoint 
        useEffect(() => {
            const loadVerification = async () => {
                try {
                    const response = await axios.put(`/api/verify-email`, {verificationString}) // verificationString as the request body, the one we'll be sending  
                    const { token } = response.data; // get the token from the response we got from the api or server 
                    setToken(token); // set the token to true since we know it already succeeded 
                    setIsSuccess(true);
                    setIsLoading(false); 
                } catch (err) { // if something goes wrong
                    setIsSuccess(false);
                    setIsLoading(false);
                }
            }
            loadVerification();
        }, [setToken, verificationString]); // only do this when this values changed 

        // show these success/fail landing pages after fetching into the server 
        if (isLoading) return <p>Loading...</p>;
        if (!isSuccess) return <EmailVerificationFail />
        return <EmailVerificationSuccess />
    }

// LESSON 2.8 - HANDLING SUCCESSFUL AND FAILED VERIFICATIONS 
// step 1: inside EmailVerificationSuccess.js 
    import { useHistory } from "react-router-dom";

    export const EmailVerificationSuccess = () => {

        const history = useHistory();

        return(
            <div className="r">
                <h1>Success!</h1>
                <p>
                    Thanks for verifying your email, now you can use all features
                </p>
                <button onClick={() => history.push()}>Go to homepage</button>
            </div>
        )
    }
// step 2: inside EmailVerificationFail.js 
    import { useHistory } from "react-router-dom";

    export const EmailVerificationSuccess = () => {

        const history = useHistory();

        return(
            <div className="r">
                <h1>Fail</h1>
                <p>
                    Something went wrong while trying to verify your email 
                </p>
                <button onClick={() => history.push("/signup")}>Back to sign up</button>
            </div>
        )
    }
// step 3: import EmailVerificationLandingPage to routes.js 
    import { BrowserRouter as Router, Route, Switch } from "react-router-dom";
    import { LogInPage } from "./pages/LogInPage";
    import { SignUpPage } from "./pages/SignUpPage";
    import { UserInfoPage} from "./pages/UserInfoPage";

    export const Routes = () => {
        return (
            <Router>
                <Switch>
                    <PrivateRoute path="/" exact> {/* remember that private route return Route */}
                        <UserInfoPage />
                    </PrivateRoute>
                    <Route path="/verify-email/:verificationString">
                        <EmailVerificationLandingPage />
                    <Route path="/login">
                        <LogInPage />
                    </Route>
                    <Route path="/please-verify">
                        <PleaseVerifyEmailPage />
                    </Route>
                    <Route path="/signup" exact>
                        <SignUpPage />
                    </Route>
                </Switch>
            </Router>
        )
    }

// LESSON 3.1 - BASIC PASSWORD RESET PROCESS 
/*
1. The user clicks "forgot password", which takes them to another page
2. The user enters their email into this page, which sends it to the server 
3. If an account with that email exists, the esrver generates a verification hash and send a link to that email address.
4. When the user clicks the link, they're taken to a landing page where they can enter a new password 
5. The new password is sent to the server which checks to make sure the verification hash matches.
6. If it matches, the user's password is updated and they can log in with their new password.
*/

// LESSON 3.2 - ADDING A FORGOT PASSWORD PAGE 
// step 1: src>pages> create a new file named ForgotPasswordPage
    // import useState for creating an initial value that can be changed, useHistory for redirection and axios for fetching api 
    import { useState } from 'react';
    import { useHistory } from 'react-router-dom';
    import axios from 'axios';

    export const ForgotPasswordPage = () => {
        const [errorMessage, setErrorMessage] = useState('');
        const [success, setSuccess] = useState(false);
        const [emailValue, setEmailValue] = useState('');
        const history = useHistory();

        const onSubmitClicked = async () => {
            try {
                await axios.put(`/api/forgot-password/${emailValue}`);
                setSuccess(true); // this is to determine which one to display for frontend 
                setTimeout(() => { // go to the login page 
                    history.push('/login');
                }, 3000);
            } catch (e) {
                setErrorMessage(e.message);
            }
        }

        // if fetching the api that checks if your email is in the database is success then do this 
        if (success) {
            return  (
                <div className="content-container">
                    <h1>Success</h1>
                    <p>Check your email for a reset link</p>
                </div>
        )} else {
            return (
                <div className="content-container">
                    <h1>Forgot Password</h1>
                    <p>Enter your email and we'll send you a reset link</p>

                    // idk what this code below does 
                    {errorMessage && <div className="fail">{errorMessage}</div>}
                    
                    <input
                        value={emailValue}
                        onChange={e => setEmailValue(e.target.value)} {/* on every changes on the input field, do this function */}
                        placeholder="someone@gmail.com" />
                    <button
                        disabled={!emailValue} {/* disable it if it has no email */}
                        onClick={onSubmitClicked()} {/* instructor has no parentheses on this function idk why */}
                    >Send Reset Link</button>
                </div>
            );}
    }
// step 2: import this page into the route 

// LESSON 3.3 - SENDING A RESET PASSWORD EMAIL 
// check if there is an account with that email address in the database 
// if there is, generate a reset code and send it to the user's email address 

// step 1: create a new route named forgotPasswordRoute.js
    import { v4 as uuid } from 'uuid'; // for generating the reset code 
    import { sendEmail } from '../util/sendEmail';
    import { getDbConnection } from '../db';

    // creating an api 
    export const forgotPasswordRoute = {
        path: '/api/forgot-password/:email',
        method: 'put',
        handler: async (req, res) => {
            const { email } = req.params; // grab the email from the parameter 

            // connecting to database 
            const db = getDbConnection('react-auth-db');
            
            // generate the password reset code 
            const passwordResetCode = uuid(); // this would generate a random string for us 

            // update the user that has this specific email and set this passwordResetCode to that user's database then grab the result 
            const { result } = await db.collection('users')
                .updateOne({ email }, { $set: { passwordResetCode } });

            // if there is a result meaning the email exists in the database, send the email to the user 
            if (result.nModified > 0) { // .nModified is how mongodb would know how many things are modified in a result 
                try {
                    await sendEmail({
                        to: email,
                        from: 'shaun.linkedin.learning@gmail.com',
                        subject: 'Password Reset',
                        text: `
                            To reset your password, click this link:
                            http://localhost:3000/reset-password/${passwordResetCode}
                        `
                    });
                } catch (e) {
                    console.log(e);
                    res.sendStatus(500);
                }
            }

            // regardless whether the email exist or not send this, this would make it more difficult for hackers to figure out who has emails on our site 
            res.sendStatus(200);
        }
    }
// step 2: import our new backend route 
import { forgotPasswordRoute } from './forgotPasswordRoute'; // just casually adding this 
import { logInRoute } from './logInRoute';
import { signUpRoute } from './signUpRoute';
import { testRoute } from './testRoute';
import { updateUserInfoRoute } from './updateUserInfoRoute';
import { verifyEmailRoute } from './verifyEmailRoute';

export const routes = [
    forgotPasswordRoute,
    logInRoute,
    signUpRoute,
    testRoute,
    updateUserInfoRoute,
    verifyEmailRoute,
];

// LESSON 3.4 - CREATING A RESET PASSWORD LANDING PAGE - defining the landing page for when the user clicked the email 
// step 1: create a new page named PasswordLandingPage.tsx, PasswordLandingFail.tsx and PasswordLandingSuccess.tsx 
// step 1.5: pass the password reset code when fetching the api 
    // inside PasswordLandingPage 
    import { useState } from 'react';
    import { useParams } from 'react-router-dom';
    import axios from 'axios';
    import { PasswordResetSuccess } from './PasswordResetSuccess';
    import { PasswordResetFail } from './PasswordResetFail';

    export const PasswordResetLandingPage = () => {
        const [isSuccess, setIsSuccess] = useState(false);
        const [isFailure, setIsFailure] = useState(false);
        const [passwordValue, setPasswordValue] = useState('');
        const [confirmPasswordValue, setConfirmPasswordValue] = useState('');
        const { passwordResetCode } = useParams();

        const onResetClicked = async () => {
            try {
                await axios.put(`/api/users/${passwordResetCode}/reset-password`, { newPassword: passwordValue });
                setIsSuccess(true);
            } catch (e) {
                setIsFailure(true);
            }
        }

        if (isFailure) return <PasswordResetFail />
        if (isSuccess) return <PasswordResetSuccess />

        
        return (
            <div className="content-container">
                <h1>Reset Password</h1>
                <p>Please enter a new password</p>
                <input
                    type='password'
                    value={passwordValue}
                    onChange={e => setPasswordValue(e.target.value)}
                    placeholder="Password" />
                <input
                    type='password'
                    value={confirmPasswordValue}
                    onChange={e => setConfirmPasswordValue(e.target.value)}
                    placeholder="Confirm Password" />
                <button
                    disabled={!passwordValue || !confirmPasswordValue || passwordValue !== confirmPasswordValue}
                    onClick={() => { onResetClicked() }}
                >Reset Password</button>
            </div>
        )
    }

// LESSON 3.5 - HANDLING PASSWORD RESET SUCCESS AND FAILURE 
// step 1: open PasswordResetSuccess 
    import { useHistory } from 'react-router-dom';

    export const PasswordResetSuccess = () => {
        const history = useHistory();

        return (
            <div className="content-container">
                <h1>Success!</h1>
                <p>
                    Your password has been reset, now please login with your new password.
                </p>
                <button onClick={() => history.push('/login')}>Log in</button>
            </div>
        );
    }
// step 2: open PasswordResetFail 
    import { useHistory } from 'react-router-dom';

    export const PasswordResetFail = () => {
        const history = useHistory();

        return (
            <div className="content-container">
                <h1>Uh oh...</h1>
                <p>
                    Something went wrong while trying to reset your password.
                </p>
                <button onClick={() => history.push('/login')}>Back to Log in</button>
            </div>
        );
    }
// step 3: import PasswordResetLandingPage into the routes

// LESSON 3.6 - ADDING A RESET PASSWORD SERVER ENDPOINT 
// step 1: create a new route 
import bcrypt from 'bcrypt'; // to hash user's password 
import { getDbConnection } from '../db';

// create a put request (update api)
export const resetPasswordRoute = {
    path: '/api/users/:passwordResetCode/reset-password',
    method: 'put',
    handler: async (req, res) => {

        // grab the reset code and the new password from the input field 
        const { passwordResetCode } = req.params;
        const { newPassword } = req.body;

        // connect to database 
        const db = getDbConnection('react-auth-db');

        // encrypt the password 
        const newPasswordHash = await bcrypt.hash(newPassword, 10);

        // update the user's password by passing the encrypted new password 
        const result = await db.collection('users')
            .findOneAndUpdate({ passwordResetCode }, {
                $set: { passwordHash: newPasswordHash },
                $unset: { passwordResetCode: '' },
            });

        // check if the user exists by checking if we modified any user's password
        if (result.lastErrorObject.n === 0) return res.sendStatus(404);

        res.sendStatus(200);
    },
}
// step 2: import the route to the main route 

// LESSON 4.1 - OAUTH BASICS - oauth is when we allow users to login using their credentials from another site such as google,linkedin, github and others 
// 3 oauth parties 
    - user 
    - our app 
    - the service provider(such as google,fb,etc.)

// oauth workflow 
    - generate a special url for the service-provider's site 
    - send the user to this url when they click "log in with ___"
    - if the user grants us permission, the service provider will redirect them back to our site with a special code 
    - our site uses this code to load the user's info 
    - we create or update the user's account with the provider's info 

// LESSON 4.2 - SETTING UP OAUTH ON GOOGLE - no point in writing this down, just watch the video when setting oauth 
// step 1: setup a project in google thru console.cloud.google.com 

// LESSON 4.3 - ADDING AN OAUTH URL ROUTE 
// step 1: create a route on our server that will generate a special url and send it back to client | create getGoogleOauthRoute.js 
// step 2: create a utility function inside src>util> getGoogleOauthUrl.js | this is a helper function that will actually take care of generating the url for us 
    import { oauthClient } from './oauthClient';

    export const getGoogleOauthUrl = () => {
        // scopes were trying to acces 
        const scopes = [
            'https://www.googleapis.com/auth/userinfo.email',
            'https://www.googleapis.com/auth/userinfo.profile',
        ];

        
        return oauthClient.generateAuthUrl({
            access_type: 'offline',
            prompt: 'consent',
            scope: scopes,
        });
    }
// step 3: create another util file: oauthClient.js | what this gonna do is just set up the google api package that we just installed with the credentials we got from the google cloud platform 
    import { google } from 'googleapis';

    export const oauthClient = new google.auth.OAuth2(
        process.env.GOOGLE_CLIENT_ID, // google api will then use to connect to our project 
        process.env.GOOGLE_CLIENT_SECRET, // process.env is injected by the node at rum for the program to use 
        'http://localhost:8080/auth/google/callback',
    );
// step 4: npm install googleapis 

// LESSON 6.1 - USING HTTPS AND SSL 
// all webapp that deal with sensitive data you need to use https, ssl, and tls (these are all the same name for the same basic idea)
// https,ssl,or tsl can prove that you as a webap can prove that you are who you say you are, and that they're not loggin in an impostor site
// seeing lock icon means they're using https and is valid
// https encrpyts the communication between the user and the site

// we register our site with a certificate authority 
// the authoriy gives us an ssl certificates we can use to verify our identity
// these certificates are usually free nowadsys and provided by default on many web hosts

// LESSON 6.2 - SALTING AND PEPPERING PASSWORDS - used alongside each other to maximize their effectiveness 
// making the password hashes that we store in our database, even more secure 

// salting - different for each user 
// generating a random string for each user and combining that with their password before hashing 
asdfas1829asjkdh + myPassword // random string + current password 
asdfas1829asjkdhmyPassword // combine 
rfgh489tusdfgadjsi // hash created from combined string and current password 

// peppering - same for all users 
// exact same thing as salting, except the random "pepper" string is the same for all users and not stored in the database 

// adding these concepts into the server 
// inside signUpRoute.js | create env variable inside .env : PEPPER_STRING=asdfafdasfafa // use random generator string
// here's what you gonna do here: create variable for salt and pepper -> include them in hashing -> include the salt when inserting into database as we want it to be unique for each user 
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import { v4 as uuid } from 'uuid'; // use this uuid as a way to generate unique salt for each user (btw this generates random string)
import { getDbConnection } from '../db';
import { sendEmail } from '../util/sendEmail';

export const signUpRoute = {
    path: '/api/signup',
    method: 'post',
    handler: async (req, res) => {
        const { email, password } = req.body;

        const db = getDbConnection('react-auth-db');
        const user = await db.collection('users').findOne({ email });

        if (user) {
            res.sendStatus(409);
        }

        const salt = uuid(); // generating random string
        const pepper = process.env.PEPPER_STRING; // use a random string for all users, variables stored in .env files are cannot be seen by backend 

        // input the random generated string + password + pepper string from .env, then hash it (ultimate password combo) 
        const passwordHash = await bcrypt.hash(salt + password + pepper, 10);

        const verificationString = uuid();

        const startingInfo = {
            hairColor: '',
            favoriteFood: '',
            bio: '',
        };

        // store the user's salt in our database 
        const result = await db.collection('users').insertOne({
            email,
            passwordHash,
            salt,
            info: startingInfo,
            isVerified: false,
            verificationString,
        });
        const { insertedId } = result;

        try {
            await sendEmail({
                to: email,
                from: 'shaun.linkedin.learning@gmail.com',
                subject: 'Please verify your email',
                text: `
                    Thanks for signing up! To verify your email, click here:
                    http://localhost:3000/verify-email/${verificationString}
                `,
            });
        } catch (e) {
            console.log(e);
            res.sendStatus(500);
        }

        jwt.sign({
            id: insertedId,
            email,
            info: startingInfo,
            isVerified: false,
        },
        process.env.JWT_SECRET,
        {
            expiresIn: '2d',
        },
        (err, token) => {
            if (err) {
                return res.status(500).send(err);
            }
            res.status(200).json({ token });
        });
    }
}

// do the same thing for loginRoute 
// after we load user from the database -> we get their salt along with their password hash in the database -> start comparing 
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import { getDbConnection } from '../db';

export const logInRoute = {
    path: '/api/login',
    method: 'post',
    handler: async (req, res) => {
        const { email, password } = req.body;

        const db = getDbConnection('react-auth-db');
        const user = await db.collection('users').findOne({ email });

        if (!user) return res.sendStatus(401);

        // we get their salt along with their password hash in the database
        const { _id: id, isVerified, passwordHash, salt, info } = user;
        const pepper = process.env.PEPPER_STRING;

        // now we compare if it matches 
        const isCorrect = await bcrypt.compare(salt + password + pepper, passwordHash);

        if (isCorrect) {
            jwt.sign({ id, isVerified, email, info }, process.env.JWT_SECRET, { expiresIn: '2d' }, (err, token) => {
                if (err) {
                    res.status(500).json(err);
                }

                res.status(200).json({ token });
            });
        } else {
            res.sendStatus(401);
        }
    },
}

// do the same thing for resetPasswordRoute 
// create new salt(salt is tied into the password not the user hehez) -> hash the new password -> store new salt into the database 
import bcrypt from 'bcrypt';
import { getDbConnection } from '../db';

export const resetPasswordRoute = {
    path: '/api/users/:passwordResetCode/reset-password',
    method: 'put',
    handler: async (req, res) => {
        const { passwordResetCode } = req.params;
        const { newPassword } = req.body;

        const db = getDbConnection('react-auth-db');

        const newSalt = uuid(); // create a new salt as you would be using a new password, salt is actually tied into the password rather than the user itself 
        const pepper = process.env.PEPPER_STRING;

        // hash the new password 
        const newPasswordHash = await bcrypt.hash(salt + newPassword + pepper, 10);

        // store new salt into the database 
        const result = await db.collection('users')
            .findOneAndUpdate({ passwordResetCode }, {
                $set: { passwordHash: newPasswordHash, salt: newSalt },
                $unset: { passwordResetCode: '' },
            });

        if (result.lastErrorObject.n === 0) return res.sendStatus(404);

        res.sendStatus(200);
    },
}

// LESSON 6.3 - NEVER TRUST THE FRONTEND 
// implement all of these in the backend 
    // make sure users can only view their own data 
    // make sure users can't store arbitrary fields in our database 
    // make sure only paid subscribers can access certain content 

// LESSON 6.4 - AUTHENTICATION ERROR HANDLING 
// dont do this 
    catch (err) {
        console.log(err); // dont print as it can send sensitive information  
    }

// LESSON 6.5 - CATCHING AND HANDLING ERRORS - do not expose unnecessary data to our client side if something goes wrong on our server 

// replace these old code 
    if (err) {
        res.status(500).json(err); // replace this 
    }
// with 
    if (err) {
        res.sendStatus(500); // now we're just sending an error message and not exposing our server side 

        // you could also do it like this 
        // res.sendStatus({ message:"there are some error"});
    }

// handling errors in frontend 
const [errorMessage, setErrorMessage] = useState("This is the default error message");

try {

} catch (e) {
    setErrorMessage(e.message); // grab the error message and send it to the user 
}
// LESSON X.1 - DEPENDENCY USED 
npm init to create node_modules to be able to install different modules/dependencies
dependencies 
    - express: for creating apis 
    - jsonwebtoken: for generating jwt 
    - dotenv 
    - bcrypt: for encrypting passwords 
    - react: front end framework
    - react-router-dom: 
    - bootstrap: styling 
    - mongodb: to be able to connect to database 
    - mongoose: to be able to connect to cloud database(mongodb)
dev-dependencies 
    - nodemon: used to automatically refresh the server so we dont have to keep on rerunning the server on every changes 
        - create a script on package.json that lets us use this nodemon 
